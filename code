""" ДИНАМІЧНИЙ ГРАФ """
def get_grid_size(relations: list) -> tuple[int, int]:
    '''
    Визначає розмір прямокутної сітки на основі відношень
    
    Args:
        relations: список пар (x, y)
        
    Returns:
        tuple: (width, height) - розміри сітки
    '''
    if not relations:
        return 0, 0

    max_x = max(x for x, _ in relations)
    max_y = max(y for _, y in relations)

    return max_x + 1, max_y + 1

def get_obstacles(relations: list, width: int, height: int) -> set:
    '''
    Визначає перешкоди - клітинки, які відсутні у відношеннях
    
    Args:
        relations: список пар (x, y) які доступні
        width: ширина сітки
        height: висота сітки
        
    Returns:
        set: множина координат перешкод
    '''
    available = set(relations)
    obstacles = set()

    for x in range(width):
        for y in range(height):
            if (x, y) not in available:
                obstacles.add((x, y))

    return obstacles


def is_valid_vertex(vertex: tuple, width: int, height: int, obstacles: set) -> bool:
    '''
    Перевірка, чи вершина є дійсною
    
    Args:
        vertex: координати (x, y)
        width: ширина сітки
        height: висота сітки
        obstacles: множина перешкод
        
    Returns:
        bool: True якщо вершина валідна
    '''
    x, y = vertex

    # Перевірка меж сітки
    if x < 0 or x >= width:
        return False
    if y < 0 or y >= height:
        return False

    # Перевірк перешкод
    if vertex in obstacles:
        return False

    return True


def get_neighbors(vertex: tuple, width: int, height: int, obstacles: set):
    '''
    Генерує сусідів вершини на льоту (не збепігає всю матрицю)
    
    Args:
        vertex: координати (x, y)
        width: ширина сітки
        height: висота сітки
        obstacles: множина перешкод
        
    Returns:
        list: список кортежів (сусід, вага)
    '''
    x, y = vertex
    neighbors = []

    # Можливі напрямки руху: вправо, вниз, вліво, вверх
    directions = [
        (1, 0),   # вправо
        (0, 1),   # вниз
        (-1, 0),  # вліво
        (0, -1)   # вверх
    ]

    # Генерація сусідів динамічно
    for dx, dy in directions:
        new_x = x + dx
        new_y = y + dy
        new_vertex = (new_x, new_y)

        # Перевіряємо чи сусід валідний
        if is_valid_vertex(new_vertex, width, height, obstacles):
            weight = 1  # вага = 1 для звичайного руху
            neighbors.append((new_vertex, weight))

    return neighbors
